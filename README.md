# FPGA_PCIE_ACCELERATOR
A template source code to build a FPGA-based accelerator, communicating host by PCIE.
This project doesn't contain any optimizations, but just to get all things work.
## What is included
Here is the complete source code to run leb128 compression on FPGA, the FPGA is connected to host via PCIE,
and the whole compression process is controlled by the host
## Workflow (H=host, C=Client FPGA)
- H2C: write the data to be compressed, into the local memory of FPGA
- H2C: write the controll regs, telling FPGA which part of data to be compressed, how long it is, and where to store result
- H2C: write a command to start compression
- C2H: wait for the compression done
- C2H: read the length of the compressed data
- C2H: read the compressed data form FPGA's local memory
The above process is general, as along as the FPGA system organizes under AXI memory-mapped bus, which is the
default oragnization of HLS. For instance, you can replace the compression IP core by some matrix multiplication ip cores.
## Hardware design
The hardware design includes the major function to conduct compression and the whole system oranization on FPGA
### Major function
The major function is written in hls, which is c/c++, it is located at vitis_hls folder.
By using vitis, you can compile the c function into standard AXI-based IP core. PLEASE DO CHECK THE TOP FUNCTION OF YOUR IP CORE!!!

Please als check the memory map generated by vitis, and the software has to follow it.
### Sytem organization and board implementation
We need to combine our functional ip core with other hardware components in building the FPGA system on chip, such as the PCIE bridge.
This is managed by the vivado tool, and you can assembly each compennet as LEGO by using the diagram design. Do remember this is more complex than LEGO, as 
we should place and connect things, and we should also 

There may remain a few verilog works if the verilog generated by diagram design doesn't satisfy our needs, such as the lack of an LED indicateor.
However, we don't have to write any functional algorithms under verilog, that's cool!

The vivado is also responsible for assigning FPGA models and its pins, if there are changes related to these, also use vivado.
Some basic operation of vivado is provided under manual folder for quick reference.
## Software design
The software includes both kernel drivers and user app.
### Kernel Driver
Run `make` under software/xdma, you will find the *.ko. The xdma is provided by AMD, please check their offical repo for updats and trouble-shooting
https://github.com/Xilinx/dma_ip_drivers.git

This driver can  work well under both x64 and aarch64, however, we found the aarch64 jetson agx can only support loading it at polling mode.
### Application
A toy example called access_leb128.c under software/test conducts the whole compression process, it is wriiten according to the hardware address map.
You can run a lazy test by `sudo ./run_test.sh`, and you will found somthing similar to expected.png
## Test conditions
Host cpu:  Jetson agx
Client FPGA: XC7K325t
Vivado/vitis version: 2022